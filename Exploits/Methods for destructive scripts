Факты и методы как можно создать мощные скрипты:

1) RemoteEvent:
Это самый распространенный способ создания хаоса. Их суть заключается в том чтобы отправлять информацию на сервер из клиента. 
Их можно вызывать абсолютно где угодно: хоть game.ReplicatedStorage, хоть если он находится на другом игроке или где либо.
Чтобы их вызвать нужно использовать RemoteEvent:FireServer(...)
А также есть RemoteFunction и чтобы их вызвать нужно использовать InvokeServer(...). В отличие от RemoteEvent они могут задерживать клиент, поэтому желательно запускать их в короутинах если их запускать циклом
Пример:

game.ReplicatedStorage.RemoteEvent:FireServer(game.Players.LocalPlayer.Character.Humanoid, "heal", 1e9) -- вызвалось
game.Players.Player1Name.Character:FindFirstChildOfClass("Tool").damage:InvokeServer(game.Players.LocalPlayer.Character.Humanoid) -- вызвалось 

for _, rem in next, plr.Character:GetDescendants() do
  if (rem:IsA("RemoteFunction") and rem.Name:lower() == "damage") then
    coroutine.wrap(function() rem:InvokeServer(plr.Character.Humanoid, math.huge) end)() 
  end
end

RemoteEvent и их аргументы можно получать при помощи хуков или так называемых Remote spy
Но есть и анти читы, которые могут детектить remote spy например "Adonis"

2) Network Ownership:
Это тоже очень распространеный метод. Когда сеть объекта находится под контролем локального игрока, то локальный игрок может делать с объектом или сущностью практически всё что угодно включая стимулировать TouchTransmitter на всех игроках.
Именно благодаря этому существуют скрипты по типу: supre ring parts, bring parts, kill all with help sword и т.д
Однако эту особенность очень легко контрить в роблокс студио всего лишь настроить сеть на сервер с помощью SetNetworkOwner: 
  part:SetNetworkOwner(nil) -- И теперь сеть принадлежит только серверу навсегда до тех пор пока сервер этого не захочет
  
Однако по умолчанию у всех игроков стоит маленький радиус симуляции: 15 студ. Но это возможно изменить с помощью параметра SimulationRadius:
game.Players.LocalPlayer.SimulationRadius = math.huge
В роблокс студио это невозможно изменить
  
И с помощью этой особенности можно сделать флинг объектами от которого обычный анти флинг не поможет
Однако я сделал скрипт, который игнорирует такие объекты делая неуязвимым к ним
Ну и ещё я сделал скрипт, который может убить всех игроков с помощью неприкреплённого объекта при условии если у него будет TouchTransmitter

3) Garbage collector (GC):
Это место где хранятся практически все даты, скрипты, ссылки, информация в локальных скриптах и практически всё на клиенте. Это очень сильный ресурс с помощью которого можно создать хаос если вариантов включая RemoteEvent нету или узнать информацию если вариантов также нету.
Мало того, что это сильная функция, так ещё и garbage collector невозможно задетектить в роблокс студио. Однако не каждый может пользоваться такой функцией
В обычной игре невозможно узнать, что находится в garbage collection, но в эксплоите это можно с помощью функции getgc(): table
У getgc есть аргумент boolean и если он настроен на true, то это означает, что в таблице будут таблицы и функции
Именно благодаря getgc существуют обходы на многие анти читы например на Adonis
Пример:

for _, v in next, getgc(true) do
  if typeof(v) == "table" and rawget(v, "Ammo") then -- это вероятно находится в модульном скрипте
    rawset(v, "Ammo", math.huge)
  end
end

4) Нет задержки:
Если в игре есть уязвимость где можно бесконечно спамить чем-то, то считай уже есть возможность создать серверный краш скрипт.
Благодаря этому я создал скрипт Radio lag на Furry infection – плейс в котором мощный анти чит и при этом я смог создать такую разрушительную функцию в таком плейсе, но потом его пофиксили через полтора месяца.
Зато как меня хвалили друзья, одноклассники и популярные скриптеры от того как я вообще додумался создать краш скрипт из ничего
Пример:

local count = 0
while true do
  count += 1
  
  game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):Activate()
  
  if count >= 50 then
    count = 0
    task.wait()
  end
end

5) ModuleScript:
Модульные скрипты могут помочь в создании мощных скриптов например убрать задержку с оружия или модифицировать его. Да, именно в getgc в основном используется изменения модульных скриптов для таких модификаций.
Благодаря изменению модульных скриптов можно создать прикольные скрипты по типу noclip camera (скрипт, который позволяет камере проходить сквозь объекты)
Именно поэтому для работы с модульными скриптами существует много функций и вот некоторые из них:
   require(ModuleScript) – Это роблокс функция. Основная функция, которая получает функции в модульном скрипте
   getloadedmodules() – Получает все модульные скрипты даже те, которые невозможно получить в роблокс студио и скрыты от обычных скриптов
   getmodules() – Не во всех эксплоитах есть данная функция, но принцип работы у неё такой же как и в getloadedmodules
Пример:

  for _, modul in next, getloadedmodules() do
    if modul:IsA("ModuleScript") and modul.Name:find("Stats") then
      local stats = require(modul)
      if rawget(stats, "cooldown") and typeof(rawget(stats, "cooldown")) == "function" then
        hookfunction(stats.cooldown, function() return 0 end) -- все элементы в require таблице являются функциями, но на всякий случай стоит проверять тип данных
      end
    end
  end
    
6) LocalScript:
Это главное преимущество для создания скрипта. Все эти пункты были бы ничем если бы они не были в локальном скрипте. Читер может всячески модифицировать и получать всё, что угодно на клиенте и даже узнать исходный код локального скрипта.
Для работы со скриптами существуют множество эксплоит функций и вот некоторые из них:
  getsenv(script: BaseScript): table – Получает окружение скрипта. Не получиться использовать итерацию на getsenv
  getscripts(): table – Получает все локальные и модуль скрипты во всей игре даже те, которые невозможно получить в роблокс студио
  getscripthash(script: BaseScript): string – Получает особый кеш скрипта
  getscriptbytecode(script: BaseScript): string – Получает байт код скрипта, а конкретно то, что может выдать в getsenv
  getcallbackvalue(BindableFunction, method: string): function – Получает функцию, которая вызывает BindableFunction
  decompile(script: BaseScript): string – Получает исходный код локального скрипта или модуль скрипта
Пример 1:

 if getsenv(game.Players.LocalPlayer.Character.Katana.LocalKatanaSctipt)["cooldownAttack"] then
   local cd = getsenv(game.Players.LocalPlayer.Character.Katana.LocalKatanaSctipt.cooldownAttack
   if cd and typeof(cd) == "number" then
     getsenv(game.Players.LocalPlayer.Character.Katana.LocalKatanaSctipt).cooldownAttack = 0
   end
 end
 
Пример 2:

for _, func in next, {wait, task.wait} do
 local hook; hook = hookfunction(func, newcclosure(function(...)
    if not checkcaller() then
        return hook()
      else
        return hook(...)
     end
  end))
end -- если действие запущено в локальном скрипте, то изменения применяться

7) Tracking:
Ну это база. Получать информацию об сервере с помощью выведения информации 
Это хоть и базовое для создания скрипта, но без этого ничего бы нормального не получилось
Пример 1:

for _, rem in next, game:GetDescendants() do
  if rem:IsA("RemoteEvent") or rem:IsA("RemoteFunction") then
    print(rem.ClassName, rem:GetFullName())
  elseif rem:IsA("ValueBase") then
    print(rem.ClassName, rem:GetFullName(), rem.Value)
  end
end

Пример 2:

for _, v in next, getgc(true) do
  if typeof(v) == "table" and rawget(v, "Ammo") then
    print("Detected")
    for i, d in next, v do
      print(i, d)
    end 
  end
end

8) Атрибуты:
Если игра не продумала про атрибуты, то вполне можно изменить их с помощью Instance:SetAttribute(attributeName: string, value: variant) на стороне сервера

9) Ффлаги:
Если так подумать, то многие возможности в эксплоитах возможны благодаря ффлагам
Например максимальное количество создаваемых потоков в роблокс студио сильно ограничено, но в эксплоитах ограничений нет
И существует ффлаг, который как раз контролирует их количество а именно: RuntimeMaxNumOfThreads (Int)

10) hookmetamethod и hookfunction:
Хуки работают только в локальном окружении, но всё же они работают. Они могут помочь для трекинга и они могут выводить настоящую информацию, а не с шифром.
С помощью этого можно создать много всякого полезного или изменения значений модульных скриптов
Пример:

local hook; hook = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
  if self == game and getnamecallmethod() == "HttpGet" then
    print(unpack({...}))
  end
  return hook(self, ...)
end))
